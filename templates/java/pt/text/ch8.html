<h1> Capítulo 8: Refinamento Stepwise </h1><hr/><p> Em grande medida, a programação é a ciência de resolver problemas por computador. Como os problemas costumam ser difíceis, as soluções - e os programas que implementam essas soluções - também podem ser difíceis. Para facilitar o desenvolvimento dessas soluções, você precisa adotar uma metodologia e disciplina que reduza o nível dessa complexidade a uma escala gerenciável. </p><p> Nos primeiros anos da programação, o conceito de computação como ciência era mais ou menos uma experiência de pensamento positivo. Ninguém sabia muito sobre programação naqueles dias, e poucos pensavam nisso como uma disciplina de engenharia no sentido convencional. À medida que a programação amadureceu, no entanto, tal disciplina começou a emergir. A pedra angular dessa disciplina é o entendimento de que a programação é feita em um ambiente social no qual os programadores devem trabalhar juntos. Se você entrar na indústria, você certamente será um dos muitos programadores que trabalham para desenvolver um grande programa. Além disso, é quase certo que esse programa continuará vivo e exigirá manutenção além do aplicativo originalmente pretendido. Alguém vai querer que o programa inclua algum novo recurso ou trabalhe de alguma maneira diferente. Quando isso ocorre, uma nova equipe de programadores deve entrar e fazer as alterações necessárias nos programas. Se os programas são escritos em um estilo individual com pouca ou nenhuma semelhança, fazer com que todos trabalhem juntos de maneira produtiva é extremamente difícil. </p><p> Para combater esse problema, os programadores começaram a desenvolver um conjunto de metodologias de programação que são coletivamente chamadas de <b>engenharia de software</b>. Usar boas habilidades de engenharia de software não só facilita a leitura e a compreensão de seus programas por outros programadores, mas também torna mais fácil para você escrever esses programas. Um dos avanços metodológicos mais importantes a surgir da engenharia de software é a estratégia do projeto <b>top-down</b> ou do <b>refinamento gradual</b>, que consiste em resolver os problemas começando pelo problema como um todo. Você quebra todo o problema em pedaços e depois resolve cada peça, quebrando-as ainda mais, se necessário. Essa estratégia de cima para baixo é complementada com <b>testes iterativos, nos</b> quais você garante que as partes menores da solução estejam funcionando antes de prosseguir. </p><h3> Um exercício no refinamento gradual </h3><p> Para ilustrar o conceito de refinamento gradual, vamos ensinar Karel a resolver um novo problema. Imagine que Karel agora está vivendo em um mundo que se parece com algo assim: </p>

<%
  include('templates/'+lang+'/programs/world.html', name="world1", world="beeperTowers", canvasWidth="400", canvasRatio=0.8)
%>

<p> Em cada uma das colunas, há uma torre de beepers de uma altura desconhecida, embora algumas colunas (como a 7ª e 9ª no mundo da amostra) possam estar vazias. O trabalho de Karel é coletar todos os apitos em cada uma dessas torres, colocá-las de volta no canto mais a leste da primeira linha e depois retornar à sua posição inicial. Assim, quando Karel terminar seu trabalho no exemplo acima, todos os 25 bipes atualmente nas torres deverão ser empilhados no canto da 9ª coluna e na 1ª linha, como segue: </p>

	<%
  include('templates/'+lang+'/programs/world.html', name="world2", world="beeperTowersGoal", canvasWidth="400", canvasRatio=0.8)
%>

<p> Importante, você pode assumir que a inicial de Karel <i>começa</i> com zeros em sua bolsa. Cada bipe captado é adicionado ao seu saco. Ao colocar beepers no canto, o karel pode usar o teste <code>bipesNoSaco()</code>. </p><p> A chave para resolver este problema é decompor o programa no caminho certo, enquanto ainda é capaz de testar como você vai. Essa tarefa é mais complexa do que as outras que você viu, o que torna a escolha de subproblemas apropriados mais importante para obter uma solução bem-sucedida. </p><h3> O princípio do design top-down </h3><p> A idéia-chave no refinamento passo a passo é que você deve iniciar o projeto do seu programa a partir do topo, que se refere ao nível do programa que é conceitualmente mais alto e mais abstrato. Nesse nível, o problema da torre dos bipes é claramente dividido em três fases independentes. Primeiro, Karel tem que recolher todos os bipes. Em segundo lugar, Karel tem que depositá-los no último cruzamento. Em terceiro lugar, Karel tem que retornar à sua posição inicial. Essa decomposição conceitual do problema sugere que o método de execução desse programa terá a seguinte estrutura: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recolherTodosOsBipers();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;soltarTodosOsBipers();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;voltarParaCasa();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Nesse nível, o problema é fácil de entender. Claro, há alguns detalhes que sobram na forma de métodos que você ainda não escreveu. Mesmo assim, é importante olhar para cada nível da decomposição e convencer-se de que, desde que você acredite que os métodos que está prestes a escrever resolverão os subproblemas corretamente, você terá uma solução para o problema como um todo. . </p><h3> Testes iterativos como você vai </h3><p> Agora que você definiu a estrutura do programa como um todo, é hora de passar para o primeiro subproblema, que consiste em coletar todos os bipes. Essa tarefa é mais complicada do que os problemas simples dos capítulos anteriores. Colecionar todos os apitos significa que você tem que pegar os apitos em todas as torres até chegar ao canto final. O fato de você precisar repetir uma operação para cada torre sugere que você precisa de um loop while aqui. O loop while repetirá o processo de <code>coletarUmaTorre</code> e depois se <code>coletarUmaTorre</code>. </p><p><b>Cuidado:</b> É perigoso tentar escrever o programa inteiro sem <b>testá</b>-lo. Se você cometer um erro, será difícil encontrar o erro. Sabemos que vamos repetir o processo de coletar uma torre. Vamos escrever e <b>testar</b> coletando uma única torre antes de colocarmos o processo <code>ColeteUmaTorre</code> em um loop for. Assim, <i>temporariliy</i>, podemos começar com a seguinte definição de pasteTodosOsBipers: <p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> recolherTodosOsBipers() {</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* implementação temporária para fins de teste */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coletarUmaTorre();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Como princípio orientador, se você tiver um loop complexo, teste o <i>corpo</i> do loop antes de gravar o loop inteiro. </p><h3> Torre de coleta de refino </h3><p> Quando coletarUmaTorre é chamado, Karel está em pé na base de uma torre de beepers ou em pé em um canto vazio. No primeiro caso, você precisa coletar os bipes na torre. No último, você pode simplesmente seguir em frente. Essa situação parece um aplicativo para a instrução if, na qual você escreveria algo assim: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(beepersPresent()){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recolherATorreReal();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Antes de adicionar essa declaração ao código, você deve pensar se precisa fazer esse teste. Freqüentemente, os programas podem ser simplificados observando-se que os casos que a princípio parecem especiais podem ser tratados exatamente da mesma maneira que a situação mais geral. No problema atual, o que acontece se você decidir que há uma torre de bipes em todas as avenidas, mas que algumas dessas torres são zero? O uso desse insight simplifica o programa porque você não precisa mais testar se há uma torre em uma determinada avenida. </p><p> O método coletarUmaTorre ainda é complexo o suficiente para que um nível adicional de decomposição esteja em ordem. Para coletar todos os bipes em uma torre, Karel precisa realizar os seguintes passos: </p><ol><li> Vire à esquerda para enfrentar os bipes na torre. <li> Colete todos os bipes na torre, parando quando não forem encontrados mais bipes. <li> Vire-se para voltar para o fundo do mundo. <li> Volte para a parede que representa o chão. <li> Vire à esquerda para estar pronto para ir para a próxima esquina. </li></li></li></li></li></ol><p> Mais uma vez, este esboço fornece um modelo para o método coletarUmaTorre, que se parece com isto: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> coletarUmaTorre(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vireAEsquerda();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coletarLinhaDeBipers();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inversãoDeMarcha();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moverParaParede();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vireAEsquerda();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><h3> Pré-condições e pós-condições do método </h3><p> Os comandos vireAEsquerda no início e no final do método coletarUmaTorre são críticos para a correção deste programa. Quando coletarUmaTorre é chamado, Karel está sempre em algum lugar na primeira linha voltada para o leste. Quando completar sua operação, o programa como um todo funcionará corretamente somente se Karel estiver voltado novamente para o leste no mesmo canto. Condições que devem ser verdadeiras antes que um método seja chamado são referidas como <b>pré-condições</b>; condições que devem ser aplicadas após o término do método são conhecidas como <b>pós-condições</b>. </p><p> Quando você define um método, você terá muito menos problemas se anotar exatamente quais são as pré e pós-condições. Depois de ter feito isso, você precisa ter certeza de que o código que você escreve sempre deixa as pós-condições satisfeitas, assumindo que as pré-condições estavam satisfeitas para começar. Por exemplo, pense no que acontece se você chamar coletarUmaTorre quando Karel estiver na primeira linha voltada para o leste. O primeiro comando vireAEsquerda deixa Karel voltado para o norte, o que significa que Karel está devidamente alinhado com a coluna de beepers que representa a torre. O método coletarLinhaDeBipers - que ainda precisa ser escrito, mas ainda assim executa uma tarefa que você entende conceitualmente - simplesmente se move sem se virar. Assim, ao final da chamada para coletarLinhaDeBipers, Karel ainda estará voltado para o norte. O chamado inversãoDeMarcha deixa Karel voltado para o sul. Como coletarLinhaDeBipers, o método moveParaParede não envolve nenhum turno, mas simplesmente se move até atingir a parede limítrofe. Como Karel está voltado para o sul, essa parede limítrofe será a que fica na parte inferior da tela, logo abaixo da primeira linha. O comando vireAEsquerda final deixa Karel na 1ª fila voltada para o leste, o que satisfaz a pós-condição. </p><h3> Repetindo o processo </h3><p> Você executa seu programa e ele consegue limpar uma torre e deixa Karel na pós-condição prometida. Wahoo! Você acaba de atingir um marco na solução dessa tarefa difícil! Agora temos que repetir o processo de limpeza de uma torre usando um loop while. </p><p> Mas como é esse loop while? Primeiro de tudo, você deve pensar no teste condicional. Você quer que Karel pare quando atingir a parede no final da linha. Assim, você quer que Karel continue enquanto o espaço na frente estiver claro. Assim, você sabe que o métodogemTodosOsBipers irá incluir um loop while que usa o teste frenteÉClaro. Em cada posição, você quer que Karel colete todos os apitos na torre começando naquele canto. Se você der a essa operação um nome, que pode ser algo como coletarUmaTorre, você pode ir em frente e escrever uma definição para o método dasAddoTodosOsBipers mesmo que você ainda não tenha preenchido os detalhes. </p><p> Você, no entanto, tem que ter cuidado. O código para pasteTodosOsBipers não se parece com isto: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> recolherTodosOsBipers(){</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* laço de buggy! */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frenteÉClaro()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coletarUmaTorre();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Esta implementação é problemática exatamente pela mesma razão que a primeira versão do geral PlaceLinhaDeSinalSonoro do capítulo 6 não conseguiu fazer o seu trabalho. Há um erro de fencepost nesta versão do código, porque Karel precisa testar a presença de uma torre de bip na última avenida. A implementação correta é: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> recolherTodosOsBipers(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frenteÉClaro()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coletarUmaTorre();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;coletarUmaTorre();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Note que este método tem exatamente a mesma estrutura que o programa principal do programa PlaceLinhaDeSinalSonoro apresentado no capítulo 6. A única diferença é que este programa chama o coletarUmaTorre onde o outro chamou o coletivo. Esses dois programas são exemplos de uma estratégia geral que se parece com isso: </p><p class="demoCode" style="margin-left:10px"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> recolherTodosOsBipers(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(frenteÉClaro()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">executa algumas operações.</i><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mover();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">executa a mesma operação para o canto final.</i><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p> Você pode usar essa estratégia sempre que precisar executar uma operação em cada esquina enquanto percorre um caminho que termina em uma parede. Se você se lembrar da estrutura geral dessa estratégia, poderá usá-la sempre que encontrar um problema que requeira tal operação. Estratégias reutilizáveis desse tipo surgem freqüentemente na programação e são referidas como <b>expressões</b> ou <b>padrões de programação</b>. Quanto mais padrões você conhecer, mais fácil será para você encontrar um que se encaixa em um tipo específico de problema. </p><h3> Terminando </h3><p> Embora o trabalho duro tenha sido feito, ainda há várias pontas soltas que precisam ser resolvidas. O programa principal chama dois métodos - soltarTodosOsBipers e voltarParaCasa - que ainda não foram escritos. Da mesma forma, coletarUmaTorre chama coletarLinhaDeBipers e moverParaParede. Felizmente, todos esses quatro métodos são simples o suficiente para codificar sem qualquer decomposição adicional, especialmente se você usar o movedorParaParede na definição de voltarParaCasa. Aqui está a implementação completa: </p>


<%
  include('templates/'+lang+'/programs/bigCode.html', name="beeperTowers",  world="beeperTowers", ideSpeed=0.9, canvasRatio=0.8)
%>


</p>