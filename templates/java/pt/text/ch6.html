<h1> Capítulo 6: While Loops </h1><hr/><p> A técnica de definir novos métodos e definir loops - por mais úteis que sejam - na verdade não permite que Karel resolva quaisquer novos problemas. Toda vez que você executa um programa, ele sempre faz exatamente a mesma coisa. Os programas se tornam muito mais úteis quando podem responder de maneira diferente a diferentes entradas. </p><p> Como um exemplo. Vamos dizer que você queria escrever um programa para que Karel fosse para uma parede. Mas você não quer simplesmente que este programa funcione em um mundo com um tamanho fixo. Você gostaria de escrever um único programa que pudesse funcionar em qualquer mundo. </p>

<%
  include('templates/'+lang+'/programs/runnableWorldChoice.html', name="moveToWall", world="7x7", canvasWidth=300, ideSpeed=0.0)
%>

<p> Tente mudar o mundo clicando no menu suspenso &quot;Alterar o mundo&quot; acima do mundo. Para qualquer tamanho de mundo, Karel se moverá até atingir uma parede. Observe que esse talento não pode ser realizado usando um loop <code class="keyword">for</code>. Isso exigiria que soubéssemos o tamanho do mundo no momento da programação. </p><h3> Loop básico While </h3><p> Em Karel, uma <code class="keyword">while</code> laço é usado para repetir um corpo de código <i>quanto-longa como</i> uma dada condição segura. O loop while tem a seguinte forma geral: </p><p class="demoCode"><code><span class="keyword">while</span>(</code><i class="demoText">test</i><code>){</code><br/><i class="demoText" style="margin-left:2em">declarações a serem repetidas</i><br/><code>}</code></p><p> O fluxo de controle de um loop while é o seguinte. Quando o programa atinge um loop while, ele começa a repetir um processo no qual primeiro <i>verifica</i> se o teste é aprovado e, se assim for, <i>executa</i> o código no corpo. </p> Quando o programa <i>verifica</i> se o teste passa, ele decide se o <i class="demoText">teste</i> é verdadeiro para o estado atual do mundo. Nesse caso, o loop executará o código no corpo. Se o teste falhar, o loop termina e o programa avança. <p> Quando o programa <i>executa</i> o corpo do loop, o programa executa as linhas no corpo, uma de cada vez. Quando o programa chega no final do loop while, ele volta para o topo do loop. Em seguida, verifica novamente o teste, continuando a repetir se ele passar. O programa não sai do loop até chegar a uma verificação e o teste falha. </p><p> Karel tem muitas declarações de <i class="demoText">teste</i>, e passaremos por todas elas no próximo capítulo. Por enquanto, vamos usar uma única instrução de teste: <code>frenteÉClaro()</code> que é verdadeira se não houver parede diretamente na frente de Karel. </p><h3> Bug de Fencepost </h3><p> Vamos modificar nosso programa acima para torná-lo mais interessante. Em vez de apenas se mover para uma parede, peça a Karel para colocar uma linha de apitos, um em cada quadrado. Mais uma vez, queremos que este programa funcione para um mundo de qualquer tamanho: </p>

<%
  include('templates/'+lang+'/programs/runnableWorldChoice.html', name="beeperLineBug1", world="7x7", canvasWidth=300, ideSpeed=0.0, isEditable="true")
%>

<p> Isso parece ótimo. Exceto por um problema. Em todos os mundos, Karel não coloca um bip no último quadrado da linha (olhe de perto). Quando Karel está no último quadrado, o programa não executa o corpo do loop porque o teste não passa mais - Karel está de frente para uma parede. Você pode ficar tentado a mudar a ordem do corpo para que Karel se mova antes de colocar um bip. O código é editável, então vá experimentá-lo! </p><p> Existe um problema mais profundo que nenhum rearranjo do corpo pode resolver. Para o mundo com 7 colunas, Karel precisa colocar 7 bipes, mas deve se mover apenas 6 vezes. Como o loop while executa as duas linhas quando um teste passa, como você pode fazer com que o programa execute um comando mais uma vez que o outro? </p><p> O bug neste programa é um exemplo de um problema de programação chamado <b>erro fencepost</b>. O nome vem do fato de que, se você quiser construir uma cerca feita de painéis que tenham um poste de vedação em qualquer tamanho, o número de postes de vedação é sempre um maior que o número de painéis. Quantas mensagens de vedação, por exemplo, você precisa construir uma cerca com 10 painéis? A resposta é 11, conforme ilustrado no diagrama a seguir: </p><center><img src="{{pathToRoot}}images/ch6/fencepost.png" style="width:500px;margin-bottom:10px"/></center><p> Depois de descobrir isso, consertar esse bug é bem fácil. Antes de Karel parar no fim do mundo, tudo o que o programa tem que fazer é colocar um bip final: </p>

<%
  include('templates/'+lang+'/programs/runnableWorldChoice.html', name="beeperLine", world="7x7", canvasWidth=300, ideSpeed=0.8, isEditable="true")
%>
