<h1 style=";text-align:right;direction:rtl"> פרק 8: צמצום שלבים </h1><hr/><p style=";text-align:right;direction:rtl"> במידה רבה, תכנות הוא מדע של פתרון בעיות על ידי המחשב. בגלל בעיות לעתים קרובות קשה, פתרונות - ואת התוכניות ליישם את הפתרונות הללו - יכול להיות קשה גם כן. על מנת להקל עליך לפתח פתרונות אלה, עליך לאמץ מתודולוגיה ומשמעת המפחיתה את רמת המורכבות הזו לסקאלה ניתנת לניהול. </p><p style=";text-align:right;direction:rtl"> בשנים הראשונות של התכנות, הרעיון של מחשוב כמדע היה פחות או יותר ניסוי של משאלת לב. איש לא ידע הרבה על תכנות באותם ימים, ומעטים חשבו עליו כעל משמעת הנדסית במובן המקובל. עם זאת, עם התפתחות התכנות, החלה משמעת כזו. אבן הפינה של אותה משמעת היא ההבנה שהתכנות נעשה בסביבה חברתית שבה מתכנתים חייבים לעבוד יחד. אם אתה נכנס לתעשייה, אתה קרוב לוודאי להיות אחד מתכנתים רבים עובדים לפתח תוכנית גדולה. תוכנית זו, יתר על כן, הוא כמעט בטוח לחיות על ותחייב תחזוקה מעבר היישום המיועד במקור. מישהו ירצה את התוכנית לכלול תכונה חדשה או עבודה בצורה אחרת. כאשר זה קורה, צוות חדש של מתכנתים חייבים להיכנס ולבצע את השינויים הדרושים בתוכניות. אם התוכניות נכתבות בסגנון אישי עם מעט או ללא שום שותפות, מקבל את כולם לעבוד יחד productively היא קשה מאוד. </p><p style=";text-align:right;direction:rtl"> כדי להתמודד עם בעיה זו, מתכנתים החלו לפתח סדרה של מתודולוגיות תכנות אשר נקראים קולקטיבית <b>הנדסת תוכנה</b>. באמצעות מיומנויות הנדסת תוכנה טובה לא רק מקל על מתכנתים אחרים לקרוא ולהבין את התוכניות שלך, אבל גם עושה את זה יותר קל לך לכתוב את התוכניות האלה מלכתחילה. אחד ההתקדמות המתודולוגית החשובה ביותר שיצאה מהנדסת תוכנה הוא האסטרטגיה של <b>תכנון מלמעלה למטה</b> או <b>חידוד שלבים</b>, אשר מורכב מפתרון בעיות על ידי התחלת הבעיה בכללה. אתה שובר את כל הבעיה לתוך חתיכות, ולאחר מכן לפתור כל פיסת, לשבור אותם למטה במידת הצורך. אסטרטגיה זו מלמעלה למטה היא השלימה עם <b>בדיקות iterative</b> שבו אתה לוודא כי חתיכות קטנות יותר של הפתרון פועלים לפני שעבר על. </p><h3 style=";text-align:right;direction:rtl"> תרגיל בעידון שלבי </h3><p style=";text-align:right;direction:rtl"> כדי להמחיש את הרעיון של חידוד צעד, בואו ללמד קארל לפתור בעיה חדשה. תארו לעצמכם כי קארל הוא חי עכשיו בעולם נראה משהו כזה: </p>

<%
  include('templates/'+lang+'/programs/world.html', name="world1", world="beeperTowers", canvasWidth="400", canvasRatio=0.8)
%>

<p style=";text-align:right;direction:rtl"> על כל אחד מהעמודים, קיים מגדל של צפצופים בגובה לא ידוע, אם כי כמה עמודות (כגון 7, 9 בעולם המדגם) עשוי להיות ריק. התפקיד של קארל הוא לאסוף את כל הביפרים בכל אחד מהמגדלים הללו, להחזיר אותם לפינה המזרחית של השורה הראשונה, ולאחר מכן לחזור למצב ההתחלה. לכן, כאשר קארל מסיים את עבודתו בדוגמה לעיל, כל 25 ביפרים כרגע במגדלים צריך להיות מוערמים בפינה של עמודה 9 ואת השורה הראשונה, כדלקמן: </p>

	<%
  include('templates/'+lang+'/programs/world.html', name="world2", world="beeperTowersGoal", canvasWidth="400", canvasRatio=0.8)
%>

<p style=";text-align:right;direction:rtl"> חשוב לציין, אתה יכול להניח כי קארל <i>מתחיל</i> עם אפס ביפר בתיק שלה. כל beeper הרים נוסף לתיק שלה. כאשר מכניסים את הביפר בפינה, קארל יכול להשתמש בבדיקת התיקייה <code>beepersבתיק()</code>. </p><p style=";text-align:right;direction:rtl"> המפתח לפתרון בעיה זו הוא לפרק את התוכנית בדרך הנכונה, ועדיין להיות מסוגל לבדוק כמו שאתה הולך. משימה זו מורכבת יותר מזו של אחרים שראית, מה שהופך את בחירת תת-הבעיות המתאימות יותר להשגת פתרון מוצלח. </p><h3 style=";text-align:right;direction:rtl"> העיקרון של עיצוב מלמעלה למטה </h3><p style=";text-align:right;direction:rtl"> הרעיון המרכזי בעידון שלבים הוא שאתה צריך להתחיל את העיצוב של התוכנית שלך מלמעלה, אשר מתייחס לרמה של התוכנית כי הוא ברמה הגבוהה ביותר מושגית ביותר מופשטים. ברמה זו, בעיית מגדל ביפר מחולקת בבירור לשלושה שלבים עצמאיים. ראשית, קארל צריך לאסוף את כל הביפרים. שנית, קארל צריך להפקיד אותם בצומת האחרון. שלישית, קארל צריך לחזור למצב הביתי שלו. הפירוק המושגי הזה של הבעיה מצביע על כך ששיטת הריצה של תוכנית זו תהיה בעלת המבנה הבא: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> run() {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףאתכלBeepers();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;כלBeepers();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לחזורהביתה();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> ברמה זו, הבעיה היא קלה להבנה. כמובן, יש כמה פרטים נותרו בצורה של שיטות שאתה עדיין לא כתוב. עם זאת, חשוב להסתכל על כל רמה של הפירוק ולשכנע את עצמך כי, כל עוד אתה מאמין כי השיטות שאתה עומד לכתוב יפתור את הבעיות subpblems כראוי, אז יהיה לך פתרון לבעיה כולה . </p><h3 style=";text-align:right;direction:rtl"> בדיקה איטרטיבית כמו שאתה הולך </h3><p style=";text-align:right;direction:rtl"> כעת, לאחר שהגדרתם את המבנה עבור התוכנית כולה, הגיע הזמן לעבור אל תת-המשנה הראשונה, המורכבת מאיסוף כל הביפרים. משימה זו עצמה מורכבת יותר מן הבעיות הפשוטות של הפרקים הקודמים. איסוף כל beepers אומר שאתה צריך להרים את הביפרים בכל מגדל עד שאתה מגיע לפינה האחרונה. העובדה שאתה צריך לחזור על הפעולה עבור כל מגדל עולה כי אתה צריך לולאה זמן כאן. הלולאה בעוד יהיה לחזור על התהליך של <code>לאסוףמגדלאחד</code> ואז זז. </p><p style=";text-align:right;direction:rtl"><b>זהירות:</b> זה מסוכן לנסות לכתוב את התוכנית כולה בלי <b>לבדוק את</b> זה כמו שאתה הולך. אם אתה עושה טעות יהיה קשה למצוא את הטעות. אנחנו יודעים שאנחנו הולכים לחזור על תהליך של איסוף מגדל אחד. תן לנו לכתוב <b>ולבדוק</b> איסוף מגדל אחד לפני שאנחנו מכניסים את תהליך <code>לאסוףמגדלאחד</code> בלולאה. לפיכך <i>temporariliy</i> נוכל להתחיל עם ההגדרה הבאה של לאסוףאתכל ביפרים: <p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> לאסוףאתכלBeepers() {</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* יישום זמני למטרות בדיקה */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףמגדלאחד();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;מהלך_\_לזוז_\_לעבור();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> כעיקרון מנחה, אם יש לך לולאה מורכבת, לבדוק את <i>הגוף</i> של לולאה לפני שאתה כותב את הלולאה כולה. </p><h3 style=";text-align:right;direction:rtl"> זיקוק לאסוף מגדל </h3><p style=";text-align:right;direction:rtl"> כאשר נקראגדגדלאחד נקרא, קארל הוא גם עומד בבסיס מגדל של ביפר או עומד על פינה ריקה. במקרה הקודם, אתה צריך לאסוף את הביפרים במגדל. בחודש האחרון, אתה יכול פשוט להמשיך הלאה. מצב זה נשמע כמו יישום להצהרה אם, שבה היית כותב דבר כזה: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>(beepersהנוכחי()){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףאתהמגדלבפועל();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> לפני שתוסיף הצהרה כזו לקוד, עליך לחשוב אם עליך לבצע בדיקה זו. לעתים קרובות, תוכניות ניתן לעשות הרבה יותר פשוט על ידי התבוננות כי במקרים בהתחלה נראה מיוחד ניתן לטפל בדיוק באותו אופן כמו המצב הכללי יותר. בבעיה הנוכחית, מה קורה אם תחליט שיש מגדל של צפצופים על כל שדרה אבל כמה מגדלים אלה אפס צפצופים גבוה? שימוש בתובנה זו מפשט את התוכנית כי אתה כבר לא צריך לבדוק אם יש מגדל בשדרה מסוימת. </p><p style=";text-align:right;direction:rtl"> השיטה &quot;גדגדחש &quot;עדיין מורכבת מספיק, עד כי רמה נוספת של פירוק היא בסדר. כדי לאסוף את כל הביפרים במגדל, על קארל לבצע את הצעדים הבאים: </p><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl"> פונים שמאלה אל הביפרים במגדל. <li style=";text-align:right;direction:rtl"> לאסוף את כל הביפרים במגדל, לעצור כאשר לא נמצאו עוד beepers. <li style=";text-align:right;direction:rtl"> להסתובב בחזרה אל החלק התחתון של העולם. <li style=";text-align:right;direction:rtl"> חזרו לקיר המייצג את הקרקע. <li style=";text-align:right;direction:rtl"> פנה שמאלה כדי להיות מוכן לעבור לפינה הבאה. </li></li></li></li></li></ol><p style=";text-align:right;direction:rtl"> שוב, מתווה זה מספק מודל לשיטתמאגדגדלאחד, שנראה כך: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> לאסוףמגדלאחד(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;פונהשמאלה();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףקושלצפצופים();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;תסתובב();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;עבוראלקיר();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;פונהשמאלה();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><h3 style=";text-align:right;direction:rtl"> תנאים מוקדמים ותנאים מוקדמים </h3><p style=";text-align:right;direction:rtl"> פונהשמאלה פקודות בתחילת וכלה בשיטת &quot;גדגדגדלאחד &quot;הן קריטיות לנכונותה של תוכנית זו. כאשר נקראגדגדלאחד נקרא, Karel הוא תמיד איפשהו בשורה הראשונה פונה מזרחה. כאשר הוא משלים את פעולתו, התוכנית כולה תעבוד כראוי רק אם קארל שוב פונה מזרחה באותה פינה. תנאים שחייבים להיות נכונים לפני שנקראת שיטה נקראים <b>תנאים מוקדמים</b>; תנאי זה חייב לחול לאחר הסיום השיטה ידועים כמו <b>postconditions</b>. </p><p style=";text-align:right;direction:rtl"> כאשר אתה מגדיר שיטה, אתה מקבל הרבה פחות צרות אם אתה כותב בדיוק מה pre- ו postconditions הם. לאחר שעשית זאת, עליך לוודא שהקוד שאתה כותב תמיד משאיר את תנאי ההתעניינות מרוצים, בהנחה שהתנאים המוקדמים היו מרוצים מלכתחילה. לדוגמה, תחשוב על מה שקורה אם אתה קורא Expגדגדלאחד כאשר קארל הוא על שורה 1 מול מזרח. הפקודה הראשונה של פונהשמאלה משאירה את קארל פונה צפונה, כלומר קארל מיושר כראוי עם עמוד ביפרים המייצג את המגדל. שיטת הקושושלצפצופים, שעדיין לא נכתבת, אבל בכל זאת מבצעת משימה שאתה מבין באופן קונספטואלי - פשוט נע בלי להסתובב. לכן, בסוף השיחה לאקקושלצפצופים, קארל עדיין ימשיך צפונה. השיחה תאתובב ולכן משאיר את קארל פונה דרומה. בדומה לאקושלצפצצופים, השיטה שלאלקקיר אינה כרוכה בשום סיבוב, אלא היא פשוט נעה עד שהיא פוגעת בקיר הגבול. מכיוון שקארל פונה דרומה, קיר הגבול הזה יהיה זה שבתחתית המסך, מתחת לשורה הראשונה. הפונה הסופי פונהשמאלה ולכן משאיר את קארל על השורה הראשונה פונה מזרחה, אשר מספק את התנאי. </p><h3 style=";text-align:right;direction:rtl"> חזרה על התהליך </h3><p style=";text-align:right;direction:rtl"> אתה מפעיל את התוכנית שלך וזה בהצלחה מנקה מגדל אחד ויוצא קארל ב postcondition הבטיח. וואהו! יש לך רק פגע אבן דרך בפתרון משימה קשה זו! עכשיו אנחנו צריכים לחזור על התהליך של ניקוי מגדל אחד באמצעות לולאה בזמן. </p><p style=";text-align:right;direction:rtl"> אבל מה זה נראה כמו לולאה? קודם כל, אתה צריך לחשוב על מבחן מותנה. אתה רוצה קארל להפסיק כאשר הוא פוגע בקיר בסוף השורה. לכן, אתה רוצה קארל להמשיך כל עוד המרחב בחזית ברור. לכן, אתה יודע כי שיטתאת ביכלס שיטת יכלול לולאה בזמן המשתמש במבחן ברור iment. בכל עמדה, אתה רוצה קארל לאסוף את כל הביפרים במגדל מתחיל בפינה. אם אתה נותן לפעולה שם, שעשוי להיות משהו כמוגדגדגד, אתה יכול להמשיך ולכתוב הגדרה לשיטת העריכה של ביכלס, למרות שעדיין לא מילאת את הפרטים. </p><p style=";text-align:right;direction:rtl"> אבל אתה צריך להיות זהיר. הקוד עבור היכולתאתכל Beepers לא נראה כך: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> לאסוףאתכלBeepers(){</code><br/><code class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* לולאה buggy! */</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(imentברור()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףמגדלאחד();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;מהלך_\_לזוז_\_לעבור();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> יישום זה הוא באגי בדיוק מאותה הסיבה כי הגירסה הראשונה של קוביפר מקום כללי מ פרק 6 נכשל לעשות את העבודה שלו. יש שגיאת הגדר בגירסה זו של הקוד, כי קארל צריך לבדוק את נוכחותו של מגדל ביפר על השדרה האחרונה. היישום הנכון הוא: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> לאסוףאתכלBeepers(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(imentברור()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףמגדלאחד();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;מהלך_\_לזוז_\_לעבור();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;לאסוףמגדלאחד();</code><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> שימו לב כי בשיטה זו יש בדיוק את אותו מבנה כמו התוכנית העיקרית של תוכנית קוביפר מקום המוצג בפרק 6. ההבדל היחיד הוא כי תוכנית זו שיחות אכמגדלאחד שבו נקרא אחראתאתפרפר. שתי התוכניות הללו הן דוגמאות לאסטרטגיה כללית שנראית כך: </p><p class="demoCode" style="margin-left:10px;text-align:right;direction:rtl"><code>&nbsp;&nbsp;&nbsp;<span class="keyword">private void</span> לאסוףאתכלBeepers(){</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span>(imentברור()) {</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">לבצע פעולה כלשהי.</i><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;מהלך_\_לזוז_\_לעבור();</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><i class="demoText">לבצע את אותה פעולה עבור הפינה האחרונה.</i><br/><code>&nbsp;&nbsp;&nbsp;}</code><br/></p><p style=";text-align:right;direction:rtl"> אתה יכול להשתמש באסטרטגיה זו בכל פעם שאתה צריך לבצע פעולה על כל פינה כפי שאתה זז לאורך נתיב מסתיים על הקיר. אם אתה זוכר את המבנה הכללי של אסטרטגיה זו, אתה יכול להשתמש בו בכל פעם שאתה נתקל בבעיה הדורשת פעולה כזו. אסטרטגיות לשימוש חוזר מסוג זה לבוא לעתים קרובות בתכנות נקראים <b>ניבים תכנות</b> או <b>דפוסים</b>. ככל שאתה יודע יותר דפוסים, כך יהיה לך קל יותר למצוא אחד שמתאים סוג מסוים של בעיה. </p><h3 style=";text-align:right;direction:rtl"> מסיים </h3><p style=";text-align:right;direction:rtl"> למרות העבודה הקשה נעשתה, יש עדיין כמה קצוות רופפים כי צריך להיפתר. התוכנית הראשית קוראת שתי שיטות - כל Beepers ו לחזורהבב, כי הם עדיין לא כתוב. באופן דומה, לאסוףמגדלאחד מכנה לאסוףקושלצפצופים ו עבוראלקיר. למרבה המזל, כל ארבעת השיטות הללו פשוטות מספיק כדי לקודד ללא כל פירוק נוסף, במיוחד אם אתה משתמש ב-אלעקיר בהגדרה של לחזורהביתה. הנה יישום מלא: </p>


<%
  include('templates/'+lang+'/programs/bigCode.html', name="beeperTowers",  world="beeperTowers", ideSpeed=0.9, canvasRatio=0.8)
%>


</p>