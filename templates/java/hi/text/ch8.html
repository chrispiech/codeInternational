<h1>अध्याय 8: स्टेपवाइज शोधन</h1>
<hr/>
<p>काफी हद तक, प्रोग्रामिंग कंप्यूटर द्वारा समस्याओं को हल करने का विज्ञान है। क्योंकि समस्याएँ अक्सर कठिन होती हैं, समाधान- और उन समाधानों को लागू करने वाले कार्यक्रम- मुश्किल भी हो सकते हैं। आपके लिए उन समाधानों को विकसित करना आसान बनाने के लिए, आपको एक ऐसी पद्धति और अनुशासन को अपनाने की आवश्यकता है जो उस जटिलता के स्तर को एक प्रबंधनीय पैमाने पर कम कर दे।</p>
<p>प्रोग्रामिंग के शुरुआती वर्षों में, विज्ञान के रूप में कंप्यूटिंग की अवधारणा इच्छाधारी सोच में एक प्रयोग था। उन दिनों में प्रोग्रामिंग के बारे में कोई भी ज्यादा नहीं जानता था, और कुछ ने पारंपरिक अर्थों में इंजीनियरिंग अनुशासन के रूप में सोचा था। जैसे-जैसे प्रोग्रामिंग परिपक्व हुई, वैसे-वैसे इस तरह का अनुशासन उभरने लगा। उस अनुशासन की आधारशिला यह समझ है कि प्रोग्रामिंग एक सामाजिक वातावरण में की जाती है जिसमें प्रोग्रामर को एक साथ काम करना होगा। यदि आप उद्योग में जाते हैं, तो आप निश्चित रूप से एक बड़े कार्यक्रम को विकसित करने के लिए काम कर रहे कई प्रोग्रामर में से एक होंगे। इसके अलावा, इस कार्यक्रम को जीना लगभग निश्चित है और इसके मूल रूप से इच्छित अनुप्रयोग से परे रखरखाव की आवश्यकता है। कोई व्यक्ति चाहेगा कि कार्यक्रम में कुछ नई सुविधा शामिल हो या कुछ अलग तरीके से काम किया जा सके। जब ऐसा होता है, तो प्रोग्रामर की एक नई टीम को कार्यक्रमों में जाना चाहिए और आवश्यक बदलाव करने चाहिए। यदि कार्यक्रमों को एक व्यक्तिगत शैली में बहुत कम या बिना किसी समानता के लिखा जाता है, तो हर किसी को एक साथ काम करना बेहद मुश्किल होता है।</p>
<p>इस समस्या से निपटने के लिए, प्रोग्रामर ने प्रोग्रामिंग पद्धति का एक समूह विकसित करना शुरू किया, जिसे सामूहिक रूप से कहा जाता है <b>सॉफ्टवेयर इंजीनियरिंग</b> । अच्छे सॉफ्टवेयर इंजीनियरिंग कौशल का उपयोग करने से न केवल अन्य प्रोग्रामरों के लिए आपके कार्यक्रमों को पढ़ना और समझना आसान हो जाता है, बल्कि आपके लिए उन कार्यक्रमों को पहली बार में लिखना भी आसान हो जाता है। सॉफ्टवेयर इंजीनियरिंग से बाहर आने के लिए सबसे महत्वपूर्ण कार्यप्रणाली में से एक रणनीति है <b>ऊपर से नीचे डिजाइन</b> या <b>चरणबद्ध शोधन</b> , जिसमें समग्र रूप से समस्या को शुरू करके समस्याओं को हल करना शामिल है। आप पूरी समस्या को टुकड़ों में तोड़ते हैं, और फिर प्रत्येक टुकड़े को हल करते हैं, यदि आवश्यक हो तो आगे नीचे तोड़ते हैं। यह टॉप डाउन रणनीति के साथ पूरक है <b>पुनरावृत्त परीक्षण</b> जहाँ आप सुनिश्चित करें कि समाधान के छोटे टुकड़े आगे बढ़ने से पहले काम कर रहे हैं।</p>
<h3>स्टेप वाइज शोधन में एक व्यायाम</h3>
<p>स्टेप वाइज शोधन की अवधारणा को समझने के लिए, करेल को एक नई समस्या को हल करने के लिए सिखाते हैं। कल्पना कीजिए कि कारेल अब एक ऐसी दुनिया में रह रहे हैं जो कुछ इस तरह दिखती है:</p>


<%
  include('templates/java/'+lang+'/programs/world.html', name="world1", world="beeperTowers", canvasWidth="400", canvasRatio=0.8)
%>


<p>प्रत्येक स्तंभ पर, अज्ञात ऊंचाई का beeper का एक टॉवर है, हालांकि कुछ कॉलम (जैसे कि 7 वें, और नमूना दुनिया में 9 वें) खाली हो सकते हैं। करेल का काम इन सभी टावरों में से सभी beeper एस को इकट्ठा करना है, उन्हें पहली पंक्ति के सबसे पूर्वी कोने पर वापस रखना है, और फिर अपनी शुरुआती स्थिति में वापस आना है। इस प्रकार, जब करेल ऊपर के उदाहरण में अपना काम पूरा कर रहे हैं, वर्तमान में सभी 25 beeper एस टावरों को 9 वें स्तंभ और पहली पंक्ति के कोने पर स्टैक्ड किया जाना चाहिए, इस प्रकार है:</p>


	<%
  include('templates/java/'+lang+'/programs/world.html', name="world2", world="beeperTowersGoal", canvasWidth="400", canvasRatio=0.8)
%>


<p>महत्वपूर्ण बात, आप मान सकते हैं कि करेल प्रारंभिक<i>शुरू होता है</i>अपने बैग में शून्य beeper एस के साथ। प्रत्येक beeper उठाया गया बैग उसके बैग में जोड़ा जाता है। जब डाल beeper कोने में है, कैरेल उपयोग कर सकते हैं <code>beepersInBag()</code> परीक्षा।</p>
<p>इस समस्या को हल करने की कुंजी कार्यक्रम को सही तरीके से विघटित करना है, जबकि आप अभी भी परीक्षण करने में सक्षम हैं। यह कार्य आपके द्वारा देखे गए अन्य की तुलना में अधिक जटिल है, जो एक सफल समाधान प्राप्त करने के लिए उचित उपप्रकारों को चुनना अधिक महत्वपूर्ण बनाता है।</p>
<h3>टॉप-डाउन डिज़ाइन का सिद्धांत</h3>
<p>स्टेप वाइज शोधन में मुख्य विचार यह है कि आपको अपने कार्यक्रम का डिज़ाइन ऊपर से शुरू करना चाहिए, जो उस कार्यक्रम के स्तर को संदर्भित करता है जो वैचारिक रूप से उच्चतम और सबसे अधिक सार है। इस स्तर पर, beeper टॉवर समस्या स्पष्ट रूप से तीन स्वतंत्र चरणों में विभाजित है। सबसे पहले, कारेल को सभी beeper एस को इकट्ठा करना है। दूसरा, कारेल को उन्हें आखिरी चौराहे पर जमा करना होगा। तीसरा, कारेल को अपने घरेलू स्थान पर लौटना होगा। समस्या के इस अवधारणात्मक अपघटन से पता चलता है कि इस कार्यक्रम के लिए run विधि में निम्नलिखित संरचना होगी:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">public void</span> run() {</code> <br/>
 <code>      सभीConoएसएकत्रकरें();</code> <br/>
 <code>      सभीConoएसड्रॉपकरें();</code> <br/>
 <code>      घरलौटना();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>इस स्तर पर, समस्या को समझना आसान है। बेशक, कुछ विवरण ऐसे तरीकों के रूप में बचे हैं जिन्हें आपने अभी तक नहीं लिखा है। फिर भी, अपघटन के प्रत्येक स्तर को देखना और अपने आप को यह समझाना ज़रूरी है कि, जब तक आप मानते हैं कि आपके द्वारा लिखी जाने वाली विधियाँ उपप्रकारों को सही ढंग से हल कर देंगी, तब आपके पास समस्या का समाधान पूरी तरह से होगा। ।</p>
<h3>जैसे ही आप जाते हैं Iterative परीक्षण</h3>
<p>अब जब आपने कार्यक्रम के लिए संरचना को एक पूरे के रूप में परिभाषित किया है, तो यह पहला move करने के लिए move का समय है, जिसमें सभी beeper एस एकत्रित होते हैं। यह कार्य पूर्ववर्ती अध्यायों की सरल समस्याओं की तुलना में अधिक जटिल है। सभी beeper एस को इकट्ठा करने का मतलब है कि आपको हर टॉवर में beeper एस को उठाना होगा जब तक आप अंतिम कोने तक नहीं पहुंच जाते। तथ्य यह है कि आपको प्रत्येक टॉवर के लिए एक ऑपरेशन को दोहराने की आवश्यकता है जो बताता है कि आपको यहां थोड़ी देर की आवश्यकता है। जबकि लूप की प्रक्रिया दोहराएगी <code>एकटावरइकट्ठाकरो</code> और फिर चल रहा है।</p>
<p> <b>सावधान:</b> इसके बिना पूरे कार्यक्रम को लिखने की कोशिश करना खतरनाक है <b>परिक्षण</b> जैसे तुम जाओ। यदि आप एक गलती करते हैं तो गलती खोजना मुश्किल होगा। हम जानते हैं कि हम एक टॉवर को इकट्ठा करने की प्रक्रिया को दोहराने जा रहे हैं। हमें लिखें और <b>परीक्षा</b> इससे पहले कि हम डाल एक एकल टॉवर का संग्रह <code>एकटावरइकट्ठाकरो</code> लूप के लिए प्रक्रिया। इस प्रकार<i>temporariliy</i>हम सभी कॉनो एसएक्रत्रकर की निम्नलिखित परिभाषा के साथ शुरू कर सकते हैं:<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void</span> सभीConoएसएकत्रकरें() {</code> <br/>
 <code class="comment">      /* परीक्षण प्रयोजनों के लिए अस्थायी कार्यान्वयन */</code> <br/>
 <code>      एकटावरइकट्ठाकरो();</code> <br/>
 <code>      move();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>एक मार्गदर्शक सिद्धांत के रूप में, यदि आपके पास एक जटिल लूप है, तो परीक्षण करें<i>तन</i>लूप से पहले आप पूरा लूप लिखें।</p>
<h3>रिफाइनिंग कलेक्शन टॉवर</h3>
<p>जब वनताराइकट्ठाकरो को बुलाया जाता है, तो करेल या तो beeper टॉवर के आधार पर खड़ा होता है या खाली कोने पर खड़ा होता है। पूर्व मामले में, आपको टॉवर में beeper एस को इकट्ठा करने की आवश्यकता है। उत्तरार्द्ध में, आप बस move पर कर सकते हैं। यह स्थिति इफ स्टेटमेंट के लिए एक एप्लिकेशन की तरह लगती है, जिसमें आप कुछ इस तरह से लिखते हैं:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">if</span>(beepersPresent()){</code> <br/>
 <code>      वास्तविकटॉवरइकट्ठा();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>इससे पहले कि आप इस तरह के बयान को कोड में शामिल करें, आपको यह सोचना चाहिए कि क्या आपको यह परीक्षण करने की आवश्यकता है। अक्सर, कार्यक्रमों को यह देखते हुए बहुत सरल बनाया जा सकता है कि पहली बार में विशेष लगने वाले मामलों को ठीक उसी तरह से व्यवहार किया जा सकता है जैसे कि सामान्य स्थिति। वर्तमान समस्या में, यदि आप यह तय करते हैं कि प्रत्येक एवेन्यू पर beeper टॉवर है, लेकिन क्या होता है, तो उनमें से कुछ टॉवर शून्य beeper उच्च हैं? इस अंतर्दृष्टि का उपयोग करने से कार्यक्रम सरल हो जाता है क्योंकि अब आपको यह परीक्षण नहीं करना है कि किसी विशेष एवेन्यू पर एक टॉवर है या नहीं।</p>
<p>एकटावराइकट्ठाकरो विधि अभी भी पर्याप्त जटिल है कि अपघटन का एक अतिरिक्त स्तर क्रम में है। एक टॉवर में सभी beeper एस को इकट्ठा करने के लिए, कारेल को निम्नलिखित कदम उठाने की आवश्यकता है:</p>
<ol>
<li>टॉवर में beeper का सामना करने के लिए बाएं मुड़ें।<li>टॉवर में सभी beeper एस लीजिए, जब कोई और अधिक beeper एस नहीं पाए जाते हैं।<li>दुनिया के नीचे की ओर वापस मुड़ने के लिए मुड़ें।<li>जमीन का प्रतिनिधित्व करने वाली दीवार पर लौटें।<li>अगले कोने में move पर तैयार होने के लिए बाएं मुड़ें।</li></li></li></li></li></ol>
<p>एक बार फिर, यह रूपरेखा एकटावराइकट्ठाकरो विधि के लिए एक मॉडल प्रदान करती है, जो इस तरह दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>एकटावरइकट्ठाकरो(){</code> <br/>
 <code>      turnLeft();</code> <br/>
 <code>      conoएसकीलाइनइकट्ठा();</code> <br/>
 <code>      turnAround();</code> <br/>
 <code>      moveदीवारकेलिए();</code> <br/>
 <code>      turnLeft();</code> <br/>
 <code>   }</code> <br/>
</p>
<h3>विधि पूर्व शर्त और पोस्टकंडिशन</h3>
<p>इस कार्यक्रम की शुद्धता के लिए एकटवराइकट्ठाकरो विधि की शुरुआत और अंत में ब्यूमुर्डिएक कमांड दोनों महत्वपूर्ण हैं। जब वनताराइकट्ठाकरो कहा जाता है, तो करेल हमेशा 1 पंक्ति पर होता है जो पूर्व की ओर है। जब यह अपना ऑपरेशन पूरा कर लेता है, तो समग्र रूप से प्रोग्राम तभी सही ढंग से काम करेगा, जब कारेल फिर से उसी कोने पर पूर्व की ओर मुंह कर रहा हो। किसी विधि को कॉल करने से पहले सत्य होने वाली शर्तों को कहा जाता है <b>पूर्व शर्त</b> ; विधि समाप्त होने के बाद लागू होने वाली शर्तों को इस रूप में जाना जाता है <b>postconditions</b> ।</p>
<p>जब आप किसी विधि को परिभाषित करते हैं, तो आप ठीक से कम परेशानी में पड़ जाएंगे यदि आप ठीक-ठीक लिखते हैं कि पूर्व और पश्चात क्या हैं। एक बार जब आप ऐसा कर लेते हैं, तो आपको यह सुनिश्चित करने की आवश्यकता होती है कि आप जो कोड लिखते हैं वह हमेशा पोस्टकंडिशन को संतुष्ट करता है, यह मानते हुए कि पूर्व शर्त के साथ शुरू करने के लिए संतुष्ट थे। उदाहरण के लिए, यह सोचें कि क्या होता है जब आप एकटावराइकट्ठाकरो को बुलाते हैं, जब करेल पहली पंक्ति में पूर्व की ओर है। पहले BandAmouriac कमांड ने कारेल का उत्तर की ओर मुंह किया, जिसका अर्थ है कि कैरेल टॉवर के प्रतिनिधित्व वाले beeper कॉलम के साथ ठीक से जुड़ा हुआ है। कोनो एसकीलाइनाइकट्ठा विधि — जिस पर लिखा जाना अभी बाकी है, लेकिन फिर भी एक ऐसा कार्य करता है जिसे आप वैचारिक रूप से समझते move केवल move बिना मोड़ के। इस प्रकार, एस.ओ. क्लाइनिनकट्ठा कोनो को कॉल के अंत में, कारेल अभी भी उत्तर की ओर मुंह करेगा। टर्नो कॉल इसलिए कारेल को दक्षिण की ओर मुंह करता है। कॉनो एसकीलाइनाइकट्ठा की तरह, move वालकिया विधि में कोई भी मोड़ शामिल नहीं है, लेकिन इसके बजाय केवल move एस जब तक यह सीमा की दीवार को हिट नहीं करता है। क्योंकि कारेल दक्षिण की ओर है, यह बाउंड्री वॉल स्क्रीन के निचले भाग में पहली पंक्ति के नीचे एक होगी। अंतिम BandAmourIVE कमांड इसलिए कर्ल को पूर्व की ओर पहली पंक्ति पर छोड़ता है, जो पोस्टकंडिशन को संतुष्ट करता है।</p>
<h3>प्रक्रिया को दोहराते हुए</h3>
<p>आप अपने कार्यक्रम को run करते हैं और यह सफलतापूर्वक एक टॉवर को साफ करता है और करेल को प्रस्तावित पोस्टकांड में छोड़ देता है। वाहू! आपने इस कठिन कार्य को सुलझाने में एक मील का पत्थर मारा है! अब हमें थोड़ी सी लूप का उपयोग करके एक टॉवर को साफ करने की प्रक्रिया को दोहराना होगा।</p>
<p>लेकिन यह क्या करता है जबकि लूप दिखता है? सबसे पहले, आपको सशर्त परीक्षण के बारे में सोचना चाहिए। आप चाहते हैं कि जब यह पंक्ति के अंत में दीवार से टकराए तो कैरेल बंद हो जाए। इस प्रकार, आप चाहते हैं कि कारेल तब तक चलते रहें जब तक सामने का स्थान स्पष्ट न हो जाए। इस प्रकार, आप जानते हैं कि सभी कोनो एसएक्रत्रकरें पद्धति में एक लूप शामिल होगा जो कि फ्रंटस्पर्टहै परीक्षण का उपयोग करता है। प्रत्येक स्थिति में, आप चाहते हैं कि कारेल उस कोने पर शुरू होने वाले टॉवर में सभी beeper एस को इकट्ठा करे। यदि आप उस ऑपरेशन को एक नाम देते हैं, जो एकटवराइकट्ठाकरो की तरह कुछ हो सकता है, तो आप आगे जा सकते हैं और सभी कॉनो एसएक्रत्रकरें विधि के लिए एक परिभाषा लिख सकते हैं, भले ही आप अभी तक विवरण में नहीं भरे हैं।</p>
<p>हालाँकि, आपको सावधान रहना होगा। सभी कोनो सक्रत्रकारों के लिए कोड इस तरह नहीं दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code class="comment">      /* छोटी गाड़ी लूप! */</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         एकटावरइकट्ठाकरो();</code> <br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>   }</code> <br/>
</p>
<p>यह कार्यान्वयन ठीक उसी कारण से छोटा है, जब अध्याय 6 से सामान्य प्लेसकोनो लाइन का पहला संस्करण अपना काम करने में विफल रहा। कोड के इस संस्करण में एक फ़र्स्टपोस्ट त्रुटि है, क्योंकि कारेल को आखिरी एवेन्यू पर beeper टॉवर की उपस्थिति के लिए परीक्षण करने की आवश्यकता है। सही कार्यान्वयन है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         एकटावरइकट्ठाकरो();</code> <br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>      एकटावरइकट्ठाकरो();</code> <br/>
 <code>   }</code> <br/>
</p>
<p>ध्यान दें कि इस विधि में ठीक वैसा ही ढांचा है जैसा कि चैप्टर 6. में प्रस्तुत प्लेकोनो लाइन कार्यक्रम के मुख्य कार्यक्रम का है। फर्क सिर्फ इतना है कि यह प्रोग्राम एकटावराइकट्ठाकरो को कॉल करता है जहां दूसरा बीपरचिपो कहलाता है। ये दो कार्यक्रम एक सामान्य रणनीति के प्रत्येक उदाहरण हैं जो इस तरह दिखता है:</p>
<p class="demoCode" style="margin-left:10px">
 <code>   <span class="keyword">private void </span>सभीConoएसएकत्रकरें(){</code> <br/>
 <code>      <span class="keyword">while</span>(frontIsClear()) {</code> <br/>
 <code>         </code> <i class="demoText">कुछ ऑपरेशन करें।</i><br/>
 <code>         move();</code> <br/>
 <code>      }</code> <br/>
 <code>      </code> <i class="demoText">अंतिम कोने के लिए एक ही ऑपरेशन करें।</i><br/>
 <code>   }</code> <br/>
</p>
<p>आप इस रणनीति का उपयोग तब कर सकते हैं जब आपको हर कोने पर एक ऑपरेशन करने की आवश्यकता होती है क्योंकि आप एक दीवार पर समाप्त होने वाले रास्ते के साथ move । यदि आपको इस रणनीति की सामान्य संरचना याद है, तो जब भी आपको ऐसी समस्या का सामना करना पड़ता है, तो आप इसका इस्तेमाल कर सकते हैं। इस तरह की पुन: प्रयोज्य रणनीति प्रोग्रामिंग में अक्सर आती है और इसे संदर्भित किया जाता है <b>प्रोग्रामिंग मुहावरे</b> या <b>पैटर्न</b> । जितने अधिक पैटर्न आप जानते हैं, उतना ही आपके लिए यह आसान होगा कि आप किसी विशेष प्रकार की समस्या को हल करें।</p>
<h3>पूरी तरह खत्म करना</h3>
<p>हालांकि कड़ी मेहनत की गई है, फिर भी कई ढीले छोर हैं जिन्हें हल करने की आवश्यकता है। मुख्य कार्यक्रम दो तरीकों को बुलाता है- सभी कॉनो एसड्रॉपकर और होमलॉइट- जो अभी तक अलिखित हैं। इसी तरह, एकतवाराइकट्ठाकरो कोनो एसकीलाइनाइकट्ठा और move वाल्किएक कहते हैं। सौभाग्य से, इन तरीकों के सभी चार, किसी भी आगे अपघटन के बिना कोड के लिए काफी सरल कर रहे हैं विशेष रूप से अगर आप का उपयोग move घरलौटना की परिभाषा में दीवारकेलिए। यहाँ पूरा कार्यान्वयन है:</p>



<%
  include('templates/java/'+lang+'/programs/bigCode.html', name="beeperTowers",  world="beeperTowers", ideSpeed=0.9, canvasRatio=0.8)
%>


</p>